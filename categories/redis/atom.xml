<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: redis | Starsea's Note]]></title>
  <link href="http://starsea.github.io/categories/redis/atom.xml" rel="self"/>
  <link href="http://starsea.github.io/"/>
  <updated>2014-08-17T21:48:17+08:00</updated>
  <id>http://starsea.github.io/</id>
  <author>
    <name><![CDATA[starsea]]></name>
    <email><![CDATA[starsea820@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[redis-hash-table-vs-json-encode]]></title>
    <link href="http://starsea.github.io/posts/redis-hash-table-vs-json-encode/"/>
    <updated>2014-08-17T21:23:35+08:00</updated>
    <id>http://starsea.github.io/posts/redis-hash-table-vs-json-encode</id>
    <content type="html"><![CDATA[<p>redis 支持多种数据结构  有时候我们在做项目的时候可能会考虑到底是用 hash 还是用普同的 k-v 结构(存储 json)</p>

<p>这里我们排除哪种结构对于程序来说更好 单从速度上来比较下</p>

<p>```php
&lt;?php
/<em>*
 *
 * @desc 用来比较 redis hash  和 json_decode 的代价
 </em>/</p>

<p>function microtime_float()
{</p>

<pre><code>list($usec, $sec) = explode(" ", microtime());
return ((float)$usec + (float)$sec);
</code></pre>

<p>}</p>

<p>$redis = new Redis();
$redis->connect(&lsquo;127.0.0.1&rsquo;, 6379);
$raw = array(</p>

<pre><code>'uid'        =&gt; 1,
'nickName'   =&gt; 2,
'role'       =&gt; 3,
'joinTime'   =&gt; 4,
'score'      =&gt; 0,
'uploadTime' =&gt; 0,
'award'      =&gt; 'zzzzzzzzz'
</code></pre>

<p>);</p>

<p>var_dump($redis->get(&lsquo;test&rsquo;));</p>

<p>$t5 = microtime_float();
for ($i = 0; $i &lt; 100000; $i++) {</p>

<pre><code>$redis-&gt;hMset('t' . $i, $raw);
</code></pre>

<p>}</p>

<p>$t6 = microtime_float();</p>

<p>for ($i = 0; $i &lt; 100000; $i++) {</p>

<pre><code>$redis-&gt;set('t' . $i . '_json', json_encode($raw));
</code></pre>

<p>}</p>

<p>$t7 = microtime_float();</p>

<p>$t1 = microtime_float();
for ($i = 0; $i &lt; 100000; $i++) {</p>

<pre><code>$redis-&gt;hGetAll('t' . $i);
</code></pre>

<p>}
$t2 = microtime_float();</p>

<p>for ($i = 0; $i &lt; 100000; $i++) {</p>

<pre><code>json_decode($redis-&gt;get('t' . $i . '_json'), true);
</code></pre>

<p>}
$t3 = microtime_float();</p>

<p>echo &lsquo;sethash &rsquo; . ($t6 &ndash; $t5) . PHP_EOL;
echo &lsquo;setjson &rsquo; . ($t7 &ndash; $t6) . PHP_EOL;</p>

<p>echo &lsquo;gethash &rsquo; . ($t2 &ndash; $t1) . PHP_EOL;</p>

<p>echo &lsquo;getjson &rsquo; . ($t3 &ndash; $t2) . PHP_EOL;</p>

<p><code>
查看下执行结果
</code>bash
[haidx@mbp:/usr/local/var/www/test]$ php json.php
bool(false)
sethash 9.2558209896088
setjson 7.8669381141663
gethash 7.9401888847351
getjson 7.5358710289001
You have new mail in /var/mail/haidx
[haidx@mbp:/usr/local/var/www/test]$ redis-memory-for-key t36275
Key             &ldquo;t36275&rdquo;
Bytes               170
Type                hash
Encoding            ziplist
Number of Elements      7
Length of Largest Element   10
[haidx@mbp:/usr/local/var/www/test]$ php json.php
bool(false)
sethash 8.133064031601
setjson 8.2587089538574
gethash 7.9228899478912
getjson 7.515007019043
```
第一次set 的时候redis db 是空的. 没多大区别</p>

<p>下面我们用真实的 hash table 测试一下
```php
$raw = array(</p>

<pre><code>'uid'        =&gt; 1,
'nickName'   =&gt; 2,
'role'       =&gt; 3,
'joinTime'   =&gt; 4,
'score'      =&gt; 0,
'uploadTime' =&gt; 0,
'award'      =&gt; 'zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz'
</code></pre>

<p>);
```</p>

<p>```bash
[haidx@mbp:/usr/local/var/www/test]$ php json.php
bool(false)
sethash 7.7665259838104
setjson 7.3227639198303
gethash 8.2078440189362
getjson 7.5661609172821
[haidx@mbp:/usr/local/var/www/test]$ php json.php
bool(false)
sethash 8.0299470424652
setjson 7.6386320590973
gethash 8.1137571334839
getjson 7.9209759235382
[haidx@mbp:/usr/local/var/www/test]$ php json.php
bool(false)
sethash 8.6087439060211
setjson 7.4942181110382
gethash 7.9777708053589
getjson 7.8165891170502
[haidx@mbp:/usr/local/var/www/test]$ php json.php
bool(false)
sethash 8.1856729984283
setjson 8.3040089607239
gethash 8.8928000926971
getjson 8.1433188915253
[haidx@mbp:/usr/local/var/www/test]$ !re
redis-memory-for-key t36275
Key             &ldquo;t36275&rdquo;
Bytes               925.0
Type                hash
Encoding            hashtable
Number of Elements      7
Length of Largest Element   91</p>

<p>[haidx@mbp:/usr/local/var/www/test]$ redis-memory-for-key t36275_json
Key             &ldquo;t36275_json&rdquo;
Bytes               272
Type                string
```
看来从 get set 上的速度来看真的没什么差别.json占的字节少一点. 所以想用什么还是根据需求吧.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[redis的连接释放问题]]></title>
    <link href="http://starsea.github.io/posts/redis-pconnect/"/>
    <updated>2014-07-09T22:12:53+08:00</updated>
    <id>http://starsea.github.io/posts/redis-pconnect</id>
    <content type="html"><![CDATA[<p>redis连接的时候有 connect 和 pconnect 两种 , 今天做项目时候用的 pconnect 手动 close 之后用 <code>redis-cli info | grep conn</code> 发现连接数并没有释放,感到奇怪,查询了很多资料后得到如下结论.</p>

<p>首先看看官方文档</p>

<h3>pconnect, popen</h3>

<hr />

<p><em><strong>Description</strong></em>: Connects to a Redis instance or reuse a connection already established with <code>pconnect</code>/<code>popen</code>.</p>

<p>The connection will not be closed on <code>close</code> or end of request until the php process ends.
So be patient on to many open FD&rsquo;s (specially on redis server side) when using persistent
connections on many servers connecting to one redis server.</p>

<p>Also more than one persistent connection can be made identified by either host + port + timeout
or host + persistent_id or unix socket + timeout.</p>

<p>This feature is not available in threaded versions. <code>pconnect</code> and <code>popen</code> then working like their non
persistent equivalents.</p>

<!--more-->


<h5><em>Parameters</em></h5>

<p><em>host</em>: string. can be a host, or the path to a unix domain socket<br/>
<em>port</em>: int, optional<br/>
<em>timeout</em>: float, value in seconds (optional, default is 0 meaning unlimited)<br/>
<em>persistent_id</em>: string. identity for the requested persistent connection
<em>retry_interval</em>: int, value in milliseconds (optional)</p>

<h5><em>Return value</em></h5>

<p><em>BOOL</em>: <code>TRUE</code> on success, <code>FALSE</code> on error.</p>

<h5><em>Example</em></h5>

<p><code>php
$redis-&gt;pconnect('127.0.0.1', 6379);
$redis-&gt;pconnect('127.0.0.1'); // port 6379 by default - same connection like before.
$redis-&gt;pconnect('127.0.0.1', 6379, 2.5); // 2.5 sec timeout and would be another connection than the two before.
$redis-&gt;pconnect('127.0.0.1', 6379, 2.5, 'x'); // x is sent as persistent_id and would be another connection the the three before.
$redis-&gt;pconnect('/tmp/redis.sock'); // unix domain socket - would be another connection than the four before.
</code></p>

<p>这里通过描述可以得知当我们使用 pconnect 的时候执行 close 或者 php 脚本请求结束后并不会关闭连接.</p>

<p>需要注意其实这里有个容易误解的地方: 手动 close 之后并不是不关闭当前连接,而是连接池不释放而已.</p>

<p>```php
&lt;?php
$redis = new \Redis();
$redis->pconnect(&lsquo;127.0.0.1&rsquo;, 6379);</p>

<p>var_dump($redis->ping(), $redis);
var_dump($redis->get(&lsquo;k1&rsquo;));</p>

<p>$redis->close();</p>

<p>echo &lsquo;===== close=======&rsquo;;</p>

<p>var_dump($redis);
var_dump($redis->get(&lsquo;k1&rsquo;));</p>

<p>try {</p>

<pre><code>$redis-&gt;ping();
</code></pre>

<p>} catch (Exception $e) {</p>

<pre><code>var_dump($e-&gt;getMessage());
</code></pre>

<p>}
?></p>

<p>```</p>

<p>得到如下结果</p>

<p><img class="/images/posts/<a" src="href="&#109;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#x51;&#81;&#50;&#48;&#49;&#x34;&#48;&#x37;&#48;&#x39;&#x2d;&#49;&#64;&#x32;&#x78;&#46;&#112;&#x6e;&#103;">&#x51;&#81;&#x32;&#x30;&#49;&#x34;&#48;&#55;&#48;&#57;&#45;&#49;&#x40;&#50;&#120;&#x2e;&#x70;&#x6e;&#103;</a>"></p>

<p>13行去 getkey 的时候抛出一个错误 说是连接已经关闭. 没错 其实这里当前 $redis 变量本身已经释放连接池的占用 其他实列可以使用该链接了. (连接池的连接上限数目和 php-fpm 的进程数目有关系)</p>

<p>这里我们注释掉13行 得到如下结果</p>

<p><img src="/images/posts/QQ20140709-1.png"></p>

<h3>总结:</h3>

<ul>
<li>pconnect 会在连接池里建立连接 不受close 的影响. close 只影响当前实列是否继续使用该连接 当然 php 脚本结束后 变量销毁 辣么连接肯定已经归还到了连接池.</li>
<li>connect 在使用的时候会建立一个连接 脚本结束后 或者 使用 close 会销毁连接.</li>
<li>close 并不会销毁 resource &hellip; = = 只是断开连接而已&hellip; unset 变量才会销毁&hellip;</li>
<li>所以并不是使用了 pconnect 就不要 close 了,如果当前脚本执行时间很长 辣么会一直占用一个连接的.详情请看<a href="http://www.laruence.com/2012/07/25/2662.html">鸟哥blog</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
